# 更新日志

## 1.9.1(2021.04.28)

---

**适配器**模式

实现了 教练叫暂停后计划对战策略案例

1. 用处：

    当原始的某个方法或者类不方便改动，但又需要新的逻辑的时候，可以考虑使用适配器模式

2. 特点：

    将需要被适配的东西通过适配器转换为被需要的东西

3. 感悟：

    感到非常实用，平时的 Model 层其实就是对 api 接口与 view 页面所需数据的适配

---

## 1.9.0(2019.11.21)

---

1.  **工厂**模式
    >     实现了 生产不同厂家鼠标案例
    >     (1) 用处：
    >         当产品对象需要进行不同的加工时可以考虑使用 工厂方法
    >     (2) 特点：
    >         把工厂抽象出来，让子工厂来决定怎么生产产品， 每个产品都由自己的工厂生产
    >         符合开闭原则
    >     (3) 注意：
    >         这不是所谓的简单工厂模式的升级版，两者有不同的应用场景
2.  **抽象工厂**模式
    >     实现了 生产不同厂家不同硬件案例
    >     (1) 用处：
    >         当需要生产的是一个产品簇，并且产品之间或多或少有关联时可以考虑使用 抽象工厂方法
    >     (2) 特点：
    >         同样隐藏了具体产品的生产，不过生产的是多种类产品
    >     (3) 注意：
    >         和工厂模式的区别：工厂模式是一个产品，而抽象工厂模式是产品簇，是线和面的区别

## 1.8.0(2019.11.20)

---

1.  **备忘录**模式
    >     实现了 游戏存，读档案例
    >     (1) 用处：
    >         当对象需要保存/加载某一时刻的状态时（如游戏的save/load）可以考虑使用 备忘录模式
    >     (2) 特点：
    >         通过保存对象之前的状态来使对象可以恢复到之前的样子
    >         又称为 快照模式
    >         备忘录模式与命令模式常常可以一同使用
    >     (3) 实现方式：
    >         发起人（Originator) ： 依赖于 Memento；负责创建一个 Memento，用来记录当前时刻它的内部状态，并可以使用 Memento 恢复内部状态；可根据需要决定 Memento 存储 Originator 的哪些内部状态
    >         备忘录（Memento) ： 负责存储 Originator 的内部状态；可以防止除 Originator 以外的其他类访问 Memento；
    >         管理者（Caretaker) ： 聚合了 Memento；负责保存 Memento

## 1.7.0(2019.11.18)

---

1.  **命令**模式

    >     实现了 餐厅点餐案例
    >     (1) 用处：
    >         当需要发送者和接收者解耦时（常用于事件响应等）可以考虑使用 命令模式
    >     (2) 特点：
    >         把请求封装成命令对象，命令对象里包含有接收者，这样 client 只需要发送命令，接收者就可以做出相关响应或相反的响应
    >         将行为请求和行为实现解耦
    >         新的命令可以很容易添加到系统中去
    >         可能会导致有过多的具体命令类
    >     (3) 实现方式：
    >         请求者类（Invoker) ： 聚合了 Command；负责调用 Command 对象发起执行
    >         命令抽象类（Command) ： 用来声明执行操作的接口
    >         具体命令类（ConcreteCommand) ： 关联了 Receiver；将一个 Receiver 对象绑定于一个动作，调用 Receiver 中相应的操作，来实现 Command 中定义的操作
    >         接受者类（Receiver) ： 负责请求具体内容的执行

2.  实现了 游戏存，读档案例
    >     希望能够完善读存，读档的方法

## 1.6.1(2019.11.12)

---

1.  实现了 餐厅点餐案例
    >     希望能够改善顾客，服务员，订单，厨师之间的高耦合情况

## 1.6.0(2019.11.11)

---

1.  **责任链**模式

    >     实现了 员工请假案例
    >     (1) 用处：
    >         当请求需要被链式处理时，且每次事件的处理者不一定时（比如事件的冒泡等），可以考虑使用 责任链模式
    >     (2) 特点：
    >         无须知道是哪个具体的处理者去处理的请求，降低了耦合度
    >         请求处理对象时，仅需要维持一个指向其后继者的引用
    >         增加或删除一个责任链时，只需要重新建立链条即可。责任链的灵活度很高
    >     (3) 实现方式：
    >         抽象 处理者（Handler) ： 定义一个处理请示的接口，需要包含可以设置后继处理者的方法和能够处理请求的抽象方法
    >         具体处理者（ConcreteHandeler) ： 处理它所负责的请求，并且可以访问它的后继者；如果可以处理该请求就直接自己处理，否则将该请求转发给它的后继者去处理

2.  **桥接**模式
    >     实现了 手机安装软件案例
    >     (1) 用处：
    >         当需要在抽象和具体实现之间增加更多的灵活性，且一个类存在两个（或多个）独立变化的维度，同时两个（或多个）维度都需要独立地进行扩展，但又不希望使用多层继承导致系统中类的个数剧增，可以考虑通过 桥接模式 使它们在抽象层建立一个关联关系
    >     (2) 特点：
    >         分离抽象部分机器具体实现部分（使抽象和继承不再在同一个继承层次中，让抽象和实现可以在各自的维度中发展）
    >         提高了系统的可扩展性
    >         符合开闭原则
    >         符合合成复用原则
    >     (3) 实现方式：
    >         抽象类（Abstraction) ： 定义抽象类的接口，该接口中定义如何使用 Implementor 接口类型对象的方法
    >         扩充抽象类（RefinedAbstraction) ： 实现由 Abstraction 定义的接口方法，可能会有自己的一些私有方法
    >         实现类接口（Implementor) ： 定义 Abstraction 抽象的实现，它可以是一个接口也可以是一个抽象类; Implementor 接口提供 Abstraction 抽象接口需要的操作，而 Abstraction 则定义了基于这些基本操作的较高层次的操作
    >         具体实现类（ConcreteImplementor) ： 实现 Implementor 接口并定义它的具体实现

## 1.5.0(2019.10.30)

---

1.  **观察者**模式
    >     实现了 订阅漫画更新案例
    >     (1) 用处：
    >         当一个对象状态的改变时需要其他对象也做出响应时可以考虑使用 观察者模式
    >     (2) 特点：
    >         观察者模式又称 发布-订阅 模式
    >         拥有对象间的一对多的依赖关系
    >         当发布者状态改变时，其他订阅了该发布者的订阅者就会收到通知
    >     (3) 实现方式：
    >         抽象 观察者/订阅者（Observer) ： 为所有的具体观察者定义一个接口，在得到更新通知时更新自己
    >         发布者（Subject) ： 将所有观察者对象的引用保存在一个数组里（观察者不限数量）；提供可以增加和删除观察者对象的方法
    >         具体 观察者/订阅者（ConcreteObserver) ：实现抽象观察者角色所要求的更新接口，以便使自身状态与发布者状态相吻合

## 1.4.0(2019.10.22)

---

1.  **单例**模式
    >     实现了 太阳月亮案例
    >     (1) 用处：
    >         需要保证一个类仅有一个实例且提供一个访问他的全局访问点时可以考虑使用 单例模式
    >     (2) 特点：
    >         类构造器私有
    >         持有自己类型的属性
    >         对外提供获取实例的静态方法
    >         分为两种：
    >             饿汉模式：线程安全，但容易产生垃圾；静态初始化的方式是在自己被加载时就将自己实例化
    >             懒汉模式：线程不安全；在第一次被引用时，才会将自己实例化
    >     (3) 实现方式：
    >         单例对象（SingleObject) ：有它的私有构造函数和本身的一个静态实例；提供了一个静态方法，供外界获取它的静态实例

## 1.3.0(2019.10.21)

---

1.  **装饰**模式
    >     实现了 人穿衣服案例
    >     (1) 用处：
    >         当需要能够动态且有顺序的为一个类增添新功能时可以考虑使用 装饰模式
    >     (2) 特点：
    >         可以提供比继承更多的灵活性
    >         通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合
    >     (3) 实现方式：
    >         对象接口 (Component) ：定义的一个对象接口，可以给这些对象动态地添加职责
    >         具体组件 (ConcreteComponent) ：被装饰的具体类，实现对象接口(Component)
    >         装饰抽象类 (Decorator)：实现了对象接口(Component)；从外类来扩展对象接口的功能；但对于对象接口来说，无需了解装饰抽象类 (Decorator)的存在
    >         具体装饰对象 (ConcreteDecorator) ：起到给对象接口 (Component)添加职责的功能

## 1.2.0(2019.10.20)

---

1.  **原型**模式
    >     实现了 克隆人案例
    >     (1) 用处：
    >         当对象的构建比较复杂时或者想得到目标对象相同内容的对象时可以考虑 原型模式
    >     (2) 特点：
    >         不需要知道对象构建的细节，直接从对象上克隆出来
    >         不会影响之前的对象的构成
    >     (3) 实现方式：
    >         通过Object.create就可以根据对象原型创建一个新的对象 or 重新 new 一个对象
    >     (4) 注意：
    >         深拷贝和浅拷贝
    >             浅拷贝：指向同一地址，一改均改
    >             深拷贝：指向两个不同地址，只改变各自的，不会互相影响

## 1.1.1(2019.10.11)

---

1.  实现了 穿衣服案例
    >     希望能够分离人和衣服之间的关系

## 1.1.0(2019.10.10)

---

1.  实现了 购物车折扣计算案例
    >     完善了 购物车折扣计算案例
2.  **策略**模式
    >     实现了 购物车折扣计算案例
    >     实现了 出行方式价格计算案例
    >     (1) 用处：
    >          在有多种算法相似的情况下，当使用 if...else 或 switch...case 所带来了代码的复杂性和臃肿性时可以考虑使用 策略模式
    >     (2) 特点：
    >          有效避免多重条件判断，增强了封装性，简化了操作，降低出错概率
    >          扩展性良好，策略类遵顼 里氏替换原则，可以很方便地进行策略扩展
    >     (3) 实现方式：
    >          上下文角色 (Context)：用来操作策略的上下文环境，屏蔽高层模块 (客户端)对策略，算法的直接访问，封装可能存在的变化；
    >          抽象策略角色 (Strategy)：规定策略或算法的行为的接口；
    >          具体策略角色 (ConcreteStrategy)：具体的策略或算法实现 (实现 Strategy 的接口)；
    >     (4) 补充：
    >          在实现策略模式时，可以结合 简单工厂设计模式 的使用，从而将 switch 生成 new Context 的部分提取出来

## 1.0.1(2019.10.09)

---

1.  实现了 购物车折扣计算案例
    >     希望能够抽出折扣计算及逻辑实现的部分

## 1.0.0(2019.10.07)

---

1.  **简单工厂**模式
    >     实现了 计算器案例
    >     (1) 用处：
    >         要 new 多个同一类型对象时可以考虑使用简单工厂
    >     (2) 特点：
    >         把同类型产品对象的创建集中到一起，通过工厂来创建；在需要添加新产品时直接加到工厂里即可。也就是把变化封装起来，同时还可以隐藏产品细节
    >     (3) 实现方式：
    >         工厂类负责 new 相关计算类，相关计算类 继承 抽象计算类

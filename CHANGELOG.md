# 更新日志

## 1.9.9(2021.12.27)

### **享元**模式

实现了 网站共享代码案例

1. 用处：

   - 如果一个应用程序使用了搭理那个的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用享元模式

   - 以及对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以使用相对较少的共享对象取代很多组对象，此时也可以考虑使用享元模式

2. 特点：

   - 享元模式即 共享元素的模式 --> 共享对象的模式

   - 享元模式可以使实例总数大量减少，如果共享的对象越多，那么存储节约的也就越多，节约量可随着共享状态的增多而增大

   - 内部状态与外部状态
      - 内部状态：在享元对象内部并且不会随环境改变而改变的共享部分
      - 外部状态：随环境改变而改变，不可以共享的状态

3. 好处：

   - 可以避免大量非常相似类的开销

---

## 1.9.8(2021.11.09)

### **中介者**模式

实现了 联合国对话案例

1. 用处：
   一般在一组对象以定义良好但是复杂的方式进行通信时；以及想要定制一个分布在多个类中的行为，但又不想生成太多子类时； 可以考虑使用中介者模式

2. 特点：

   - 中介者模式很容易在系统中应用，也很容易在系统中误用。当系统中出现了‘多对多’的复杂对象群时，不要急于使用中介者模式，而是首先要反思你的系统在设计上是否合理

   - 中介者模式的缺点也是显而易见，由于中介者对象的功能过于集中化，也就是将交互的复杂性变成了中介者的复杂性，这会很容易让中介者对象变得比任何一个具体同事对象都更加复杂

3. 好处：
   通过中介者对象可以将系统中的网状结构变成以中介者为中心的星型结构，每个具体对象不再通过直接的联系与另一个对象发生相互作用，而是通过中介者对象与另一个对象发生相互作用

---

## 1.9.7(2021.11.02)

### **迭代器**模式

实现了 买票案例

1. 用处：
   当你需要访问一个聚集对象，并且对聚集有多种方式遍历的时候，就应该考虑使用迭代器模式

2. 特点：

   - 迭代器模式为遍历不同的聚集结构提供了如开始、下一个、是否结束、当前某一项等统一的接口

   - 迭代器模式在访问数组、集合、列表等数据时，尤其是对于数据库的数据操作时，是非常普遍的应用，但由于它用处太普遍了，所以各种高级语言也都对他进行了封装，因此反倒是给人感觉其本身不是很常用了

3. 好处：
   通过抽出一个迭代器类来分离集合对象的遍历行为，这样既可以不暴露集合的内部结构，又可以让外部代码透明地访问集合内部的数据

---

## 1.9.6(2021.10.12)

### **状态**模式

实现了 打工人不同时段工作状态案例

1. 用处：
   当一个对象的行为取决于它的状态，并且它必须在运行时时刻根据状态改变它的行为时，就可以考虑使用状态模式了

2. 特点：

   - 当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类

   - 主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况（例如大量的 `if else` 语句）。将状态的判断逻辑转移到表示不同状态的一系列类之中，可以把复杂的判断逻辑简化

   - 通过把各种状态转移逻辑分布到 State 的子类之间，来减少相互间的依赖（开闭原则）

3. 好处：
   将与特定状态相关的行为局部化，并且将不同状态的行为分割开来

---

## 1.9.5(2021.09.06)

### **组合**模式

实现了 公司树形结构管理案例

1. 用处：
   需求中是体现部分与整体层次的结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该使用组合模式啦

2. 特点：

   - 组合模式定义了包含基本对象和组合对象的类层次结构

   - 基本对象可以被组合成为更复杂的组合对象，而这个对象又可以被组合，这样子不断递归下去，最后在应用时，任何用到基本对象的地方就都可以使用组合对象了

   - 组合模式在应用时可以一致性地使用组合结构和单个对象

---

## 1.9.4(2021.09.03)

### **建造者**模式

实现了 创建胖、瘦小人案例

1. 用处：

   主要用于创建一些复杂的对象，这些对象的内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化

2. 特点：

   - 使得建造代码与表示代码分离，使同样的建造过程可以创建不同的表示

   - 如果需要改变一个产品的内部表示，只需要再定义一个具体的建造者就可以了

   - 建造者模式是在当在创建复杂对象的算法应该独立于对象的组成部分以及它们的装配方式时适用的模式

---

## 1.9.3(2021.06.10)

增添了 观察者设计模式 中 气象站发布新消息，诸多公告牌进行更新的案例

---

## 1.9.2(2021.05.06)

---

### **模板方法**模式

实现了 学生抄写试题案例

1. 用处：

   当不可变和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。通过模板方法模式把这些行为搬移到单一的地方，这样就可以帮助子类摆脱重复不变的行为的纠缠。

2. 特点：

   通过把不变的行为搬移到抽象类中，去除子类中的重复代码来体现其优势

3. 感悟：

   感到非常实用，天天在用，平时对于公用逻辑或者业务在抽取抽象类的过程就是这个设计模式的实现

### **外观/门面**模式

实现了 股民炒股案例

1. 用处：

   - 在层与层之间可以建立外观模式。
   - 在开发时，子系统往往会因为不断重构演化而变得越来越复杂，增加一个外观类可以提供一个简单的接口，减少它们之间的依赖。
   - 在维护一个遗留的大型系统时，也可以为新系统开发一个外观类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让新系统与外观对象交互，外观对象与遗留代码交互所有复杂的工作。

2. 特点：

   - 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

3. 感悟：

   - 外观和适配器模式都可以包装许多类。
   - 但外观的意图是简化接口，而适配器的意图是将接口转换成不同的接口

---

## 1.9.2(2021.04.30)

---

### **代理**模式

实现了 追求女生的案例

1. 用处：

   远程代理、虚拟代理、安全代理、智能指引

2. 特点：

   将其他对象提供一种代理以控制对这个对象的访问

---

## 1.9.1(2021.04.28)

---

### **适配器**模式

实现了 教练叫暂停后计划对战策略案例

1. 用处：

   当原始的某个方法或者类不方便改动，但又需要新的逻辑的时候，可以考虑使用适配器模式

2. 特点：

   将需要被适配的东西通过适配器转换为被需要的东西

3. 感悟：

   感到非常实用，平时的 Model 层其实就是对 api 接口与 view 页面所需数据的适配

### **代理**模式

实现了 追求女生的案例

---

## 1.9.0(2019.11.21)

---

1.  **工厂**模式
    >     实现了 生产不同厂家鼠标案例
    >     (1) 用处：
    >         当产品对象需要进行不同的加工时可以考虑使用 工厂方法
    >     (2) 特点：
    >         把工厂抽象出来，让子工厂来决定怎么生产产品， 每个产品都由自己的工厂生产
    >         符合开闭原则
    >     (3) 注意：
    >         这不是所谓的简单工厂模式的升级版，两者有不同的应用场景
2.  **抽象工厂**模式
    >     实现了 生产不同厂家不同硬件案例
    >     (1) 用处：
    >         当需要生产的是一个产品簇，并且产品之间或多或少有关联时可以考虑使用 抽象工厂方法
    >     (2) 特点：
    >         同样隐藏了具体产品的生产，不过生产的是多种类产品
    >     (3) 注意：
    >         和工厂模式的区别：工厂模式是一个产品，而抽象工厂模式是产品簇，是线和面的区别

## 1.8.0(2019.11.20)

---

1.  **备忘录**模式
    >     实现了 游戏存，读档案例
    >     (1) 用处：
    >         当对象需要保存/加载某一时刻的状态时（如游戏的save/load）可以考虑使用 备忘录模式
    >     (2) 特点：
    >         通过保存对象之前的状态来使对象可以恢复到之前的样子
    >         又称为 快照模式
    >         备忘录模式与命令模式常常可以一同使用
    >     (3) 实现方式：
    >         发起人（Originator) ： 依赖于 Memento；负责创建一个 Memento，用来记录当前时刻它的内部状态，并可以使用 Memento 恢复内部状态；可根据需要决定 Memento 存储 Originator 的哪些内部状态
    >         备忘录（Memento) ： 负责存储 Originator 的内部状态；可以防止除 Originator 以外的其他类访问 Memento；
    >         管理者（Caretaker) ： 聚合了 Memento；负责保存 Memento

## 1.7.0(2019.11.18)

---

1.  **命令**模式

    >     实现了 餐厅点餐案例
    >     (1) 用处：
    >         当需要发送者和接收者解耦时（常用于事件响应等）可以考虑使用 命令模式
    >     (2) 特点：
    >         把请求封装成命令对象，命令对象里包含有接收者，这样 client 只需要发送命令，接收者就可以做出相关响应或相反的响应
    >         将行为请求和行为实现解耦
    >         新的命令可以很容易添加到系统中去
    >         可能会导致有过多的具体命令类
    >     (3) 实现方式：
    >         请求者类（Invoker) ： 聚合了 Command；负责调用 Command 对象发起执行
    >         命令抽象类（Command) ： 用来声明执行操作的接口
    >         具体命令类（ConcreteCommand) ： 关联了 Receiver；将一个 Receiver 对象绑定于一个动作，调用 Receiver 中相应的操作，来实现 Command 中定义的操作
    >         接受者类（Receiver) ： 负责请求具体内容的执行

2.  实现了 游戏存，读档案例
    >     希望能够完善读存，读档的方法

## 1.6.1(2019.11.12)

---

1.  实现了 餐厅点餐案例
    >     希望能够改善顾客，服务员，订单，厨师之间的高耦合情况

## 1.6.0(2019.11.11)

---

1.  **责任链**模式

    >     实现了 员工请假案例
    >     (1) 用处：
    >         当请求需要被链式处理时，且每次事件的处理者不一定时（比如事件的冒泡等），可以考虑使用 责任链模式
    >     (2) 特点：
    >         无须知道是哪个具体的处理者去处理的请求，降低了耦合度
    >         请求处理对象时，仅需要维持一个指向其后继者的引用
    >         增加或删除一个责任链时，只需要重新建立链条即可。责任链的灵活度很高
    >     (3) 实现方式：
    >         抽象 处理者（Handler) ： 定义一个处理请示的接口，需要包含可以设置后继处理者的方法和能够处理请求的抽象方法
    >         具体处理者（ConcreteHandeler) ： 处理它所负责的请求，并且可以访问它的后继者；如果可以处理该请求就直接自己处理，否则将该请求转发给它的后继者去处理

2.  **桥接**模式
    >     实现了 手机安装软件案例
    >     (1) 用处：
    >         当需要在抽象和具体实现之间增加更多的灵活性，且一个类存在两个（或多个）独立变化的维度，同时两个（或多个）维度都需要独立地进行扩展，但又不希望使用多层继承导致系统中类的个数剧增，可以考虑通过 桥接模式 使它们在抽象层建立一个关联关系
    >     (2) 特点：
    >         分离抽象部分机器具体实现部分（使抽象和继承不再在同一个继承层次中，让抽象和实现可以在各自的维度中发展）
    >         提高了系统的可扩展性
    >         符合开闭原则
    >         符合合成复用原则
    >     (3) 实现方式：
    >         抽象类（Abstraction) ： 定义抽象类的接口，该接口中定义如何使用 Implementor 接口类型对象的方法
    >         扩充抽象类（RefinedAbstraction) ： 实现由 Abstraction 定义的接口方法，可能会有自己的一些私有方法
    >         实现类接口（Implementor) ： 定义 Abstraction 抽象的实现，它可以是一个接口也可以是一个抽象类; Implementor 接口提供 Abstraction 抽象接口需要的操作，而 Abstraction 则定义了基于这些基本操作的较高层次的操作
    >         具体实现类（ConcreteImplementor) ： 实现 Implementor 接口并定义它的具体实现

## 1.5.0(2019.10.30)

---

1.  **观察者**模式
    >     实现了 订阅漫画更新案例
    >     (1) 用处：
    >         当一个对象状态的改变时需要其他对象也做出响应时可以考虑使用 观察者模式
    >     (2) 特点：
    >         观察者模式又称 发布-订阅 模式
    >         拥有对象间的一对多的依赖关系
    >         当发布者状态改变时，其他订阅了该发布者的订阅者就会收到通知
    >     (3) 实现方式：
    >         抽象 观察者/订阅者（Observer) ： 为所有的具体观察者定义一个接口，在得到更新通知时更新自己
    >         发布者（Subject) ： 将所有观察者对象的引用保存在一个数组里（观察者不限数量）；提供可以增加和删除观察者对象的方法
    >         具体 观察者/订阅者（ConcreteObserver) ：实现抽象观察者角色所要求的更新接口，以便使自身状态与发布者状态相吻合

## 1.4.0(2019.10.22)

---

1.  **单例**模式
    >     实现了 太阳月亮案例
    >     (1) 用处：
    >         需要保证一个类仅有一个实例且提供一个访问他的全局访问点时可以考虑使用 单例模式
    >     (2) 特点：
    >         类构造器私有
    >         持有自己类型的属性
    >         对外提供获取实例的静态方法
    >         分为两种：
    >             饿汉模式：线程安全，但容易产生垃圾；静态初始化的方式是在自己被加载时就将自己实例化
    >             懒汉模式：线程不安全；在第一次被引用时，才会将自己实例化
    >     (3) 实现方式：
    >         单例对象（SingleObject) ：有它的私有构造函数和本身的一个静态实例；提供了一个静态方法，供外界获取它的静态实例

## 1.3.0(2019.10.21)

---

1.  **装饰**模式
    >     实现了 人穿衣服案例
    >     (1) 用处：
    >         当需要能够动态且有顺序的为一个类增添新功能时可以考虑使用 装饰模式
    >     (2) 特点：
    >         可以提供比继承更多的灵活性
    >         通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合
    >     (3) 实现方式：
    >         对象接口 (Component) ：定义的一个对象接口，可以给这些对象动态地添加职责
    >         具体组件 (ConcreteComponent) ：被装饰的具体类，实现对象接口(Component)
    >         装饰抽象类 (Decorator)：实现了对象接口(Component)；从外类来扩展对象接口的功能；但对于对象接口来说，无需了解装饰抽象类 (Decorator)的存在
    >         具体装饰对象 (ConcreteDecorator) ：起到给对象接口 (Component)添加职责的功能

## 1.2.0(2019.10.20)

---

1.  **原型**模式
    >     实现了 克隆人案例
    >     (1) 用处：
    >         当对象的构建比较复杂时或者想得到目标对象相同内容的对象时可以考虑 原型模式
    >     (2) 特点：
    >         不需要知道对象构建的细节，直接从对象上克隆出来
    >         不会影响之前的对象的构成
    >     (3) 实现方式：
    >         通过Object.create就可以根据对象原型创建一个新的对象 or 重新 new 一个对象
    >     (4) 注意：
    >         深拷贝和浅拷贝
    >             浅拷贝：指向同一地址，一改均改
    >             深拷贝：指向两个不同地址，只改变各自的，不会互相影响

## 1.1.1(2019.10.11)

---

1.  实现了 穿衣服案例
    >     希望能够分离人和衣服之间的关系

## 1.1.0(2019.10.10)

---

1.  实现了 购物车折扣计算案例
    >     完善了 购物车折扣计算案例
2.  **策略**模式
    >     实现了 购物车折扣计算案例
    >     实现了 出行方式价格计算案例
    >     (1) 用处：
    >          在有多种算法相似的情况下，当使用 if...else 或 switch...case 所带来了代码的复杂性和臃肿性时可以考虑使用 策略模式
    >     (2) 特点：
    >          有效避免多重条件判断，增强了封装性，简化了操作，降低出错概率
    >          扩展性良好，策略类遵顼 里氏替换原则，可以很方便地进行策略扩展
    >     (3) 实现方式：
    >          上下文角色 (Context)：用来操作策略的上下文环境，屏蔽高层模块 (客户端)对策略，算法的直接访问，封装可能存在的变化；
    >          抽象策略角色 (Strategy)：规定策略或算法的行为的接口；
    >          具体策略角色 (ConcreteStrategy)：具体的策略或算法实现 (实现 Strategy 的接口)；
    >     (4) 补充：
    >          在实现策略模式时，可以结合 简单工厂设计模式 的使用，从而将 switch 生成 new Context 的部分提取出来

## 1.0.1(2019.10.09)

---

1.  实现了 购物车折扣计算案例
    >     希望能够抽出折扣计算及逻辑实现的部分

## 1.0.0(2019.10.07)

---

1.  **简单工厂**模式
    >     实现了 计算器案例
    >     (1) 用处：
    >         要 new 多个同一类型对象时可以考虑使用简单工厂
    >     (2) 特点：
    >         把同类型产品对象的创建集中到一起，通过工厂来创建；在需要添加新产品时直接加到工厂里即可。也就是把变化封装起来，同时还可以隐藏产品细节
    >     (3) 实现方式：
    >         工厂类负责 new 相关计算类，相关计算类 继承 抽象计算类

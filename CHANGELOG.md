# 更新日志

## 1.4.0(2019.10.22)

---

1. **单例**模式
>     实现了 太阳月亮案例
>     (1) 用处：
>         需要保证一个类仅有一个实例且提供一个访问他的全局访问点时可以考虑使用 单例模式
>     (2) 特点：
>         类构造器私有
>         持有自己类型的属性
>         对外提供获取实例的静态方法
>         分为两种：
>             饿汉模式：线程安全，但容易产生垃圾；静态初始化的方式是在自己被加载时就将自己实例化
>             懒汉模式：线程不安全；在第一次被引用时，才会将自己实例化
>     (3) 实现方式：
>         单例对象（SingleObject) ：有它的私有构造函数和本身的一个静态实例；提供了一个静态方法，供外界获取它的静态实例


## 1.3.0(2019.10.21)

---

1. **装饰**模式
>     实现了 人穿衣服案例
>     (1) 用处：
>         当需要能够动态且有顺序的为一个类增添新功能时可以考虑使用 装饰模式
>     (2) 特点：
>         可以提供比继承更多的灵活性
>         通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合
>     (3) 实现方式：
>         对象接口 (Component) ：定义的一个对象接口，可以给这些对象动态地添加职责
>         具体组件 (ConcreteComponent) ：被装饰的具体类，实现对象接口(Component)
>         装饰抽象类 (Decorator)：实现了对象接口(Component)；从外类来扩展对象接口的功能；但对于对象接口来说，无需了解装饰抽象类 (Decorator)的存在
>         具体装饰对象 (ConcreteDecorator) ：起到给对象接口 (Component)添加职责的功能

## 1.2.0(2019.10.20)

---

1. **原型**模式
>     实现了 克隆人案例
>     (1) 用处：
>         当对象的构建比较复杂时或者想得到目标对象相同内容的对象时可以考虑 原型模式
>     (2) 特点：
>         不需要知道对象构建的细节，直接从对象上克隆出来
>         不会影响之前的对象的构成
>     (3) 实现方式：
>         通过Object.create就可以根据对象原型创建一个新的对象 or 重新 new 一个对象
>     (4) 注意：
>         深拷贝和浅拷贝
>             浅拷贝：指向同一地址，一改均改
>             深拷贝：指向两个不同地址，只改变各自的，不会互相影响

## 1.1.1(2019.10.11)

---

1. 实现了 穿衣服案例
>     希望能够分离人和衣服之间的关系

## 1.1.0(2019.10.10)

---

1. 实现了 购物车折扣计算案例
>     完善了 购物车折扣计算案例
2. **策略**模式
>     实现了 购物车折扣计算案例
>     实现了 出行方式价格计算案例
>     (1) 用处：
>          在有多种算法相似的情况下，当使用 if...else 或 switch...case 所带来了代码的复杂性和臃肿性时可以考虑使用 策略模式
>     (2) 特点：
>          有效避免多重条件判断，增强了封装性，简化了操作，降低出错概率
>          扩展性良好，策略类遵顼 里氏替换原则，可以很方便地进行策略扩展
>     (3) 实现方式：
>          上下文角色 (Context)：用来操作策略的上下文环境，屏蔽高层模块 (客户端)对策略，算法的直接访问，封装可能存在的变化；
>          抽象策略角色 (Strategy)：规定策略或算法的行为的接口；
>          具体策略角色 (ConcreteStrategy)：具体的策略或算法实现 (实现 Strategy 的接口)；
>     (4) 补充：
>          在实现策略模式时，可以结合 简单工厂设计模式 的使用，从而将 switch 生成 new Context 的部分提取出来

## 1.0.1(2019.10.09)

---

1. 实现了 购物车折扣计算案例
>     希望能够抽出折扣计算及逻辑实现的部分

## 1.0.0(2019.10.07)

---

1. **简单工厂**模式
>     实现了 计算器案例
>     (1) 用处：
>         要 new 多个同一类型对象时可以考虑使用简单工厂
>     (2) 特点：
>         把同类型产品对象的创建集中到一起，通过工厂来创建；在需要添加新产品时直接加到工厂里即可。也就是把变化封装起来，同时还可以隐藏产品细节
>     (3) 实现方式：
>         工厂类负责 new 相关计算类，相关计算类 继承 抽象计算类
# 更新日志

## 1.2.1(2019.10.11)

---

1. **原型**设计模式
>     实现了 克隆人案例
>     (1) 用处：
>         当对象的构建比较复杂时或者想得到目标对象相同内容的对象时可以考虑 原型模式
>     (2) 特点：
>         不需要知道对象构建的细节，直接从对象上克隆出来
>         不会影响之前的对象的构成
>     (3) 实现方式：
>         通过Object.create就可以根据对象原型创建一个新的对象 or 重新 new 一个对象
>     (4) 注意：
>         深拷贝和浅拷贝
>             浅拷贝：指向同一地址，一改均改
>             深拷贝：指向两个不同地址，只改变各自的，不会互相影响

## 1.1.1(2019.10.11)

---

1. 实现了 穿衣服案例
>     希望能够分离人和衣服之间的关系

## 1.1.0(2019.10.10)

---

1. 实现了 购物车折扣计算案例
>     完善了 购物车折扣计算案例
2. **策略**设计模式
>     实现了 购物车折扣计算案例
>     实现了 出行方式价格计算案例
>     (1) 用处：
>          在有多种算法相似的情况下，当使用 if...else 或 switch...case 所带来了代码的复杂性和臃肿性时可以考虑使用 策略模式
>     (2) 特点：
>          有效避免多重条件判断，增强了封装性，简化了操作，降低出错概率
>          扩展性良好，策略类遵顼 里氏替换原则，可以很方便地进行策略扩展
>     (3) 实现方式：
>          上下文角色（Context）：用来操作策略的上下文环境，屏蔽高层模块（客户端）对策略，算法的直接访问，封装可能存在的变化；
>          抽象策略角色（Strategy）：规定策略或算法的行为的接口；
>          具体策略角色（ConcreteStrategy）：具体的策略或算法实现（实现 Strategy 的接口）；
>     (4) 补充：
>          在实现策略模式时，可以结合 简单工厂设计模式 的使用，从而将 switch 生成 new Context 的部分提取出来

## 1.0.1(2019.10.09)

---

1. 实现了 购物车折扣计算案例
>     希望能够抽出折扣计算及逻辑实现的部分

## 1.0.0(2019.10.07)

---

1. **简单工厂**设计模式
>     实现了 计算器案例
>     (1) 用处：
>         - 要 new 多个同一类型对象时可以考虑使用简单工厂
>     (2) 特点：
>         - 把同类型产品对象的创建集中到一起，通过工厂来创建；在需要添加新产品时直接加到工厂里即可。也就是把变化封装起来，同时还可以隐藏产品细节
>     (3) 实现方式：
>         - 工厂类负责 new 相关计算类，相关计算类 继承 抽象计算类